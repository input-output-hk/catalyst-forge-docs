# Configuration & Discovery Specification

## Executive Summary
Complete reference for all configuration and discovery mechanisms in the Catalyst Forge platform. This document defines the CUE-based configuration system, repository structure conventions, and automated discovery rules.

## Core Concepts

### Repository and Project Distinction

The platform distinguishes between repository-level and project-level configuration:

- **Repository Configuration**: Defined in `.forge/repo.cue` at the repository root, establishes platform-wide settings
- **Project Configuration**: Defined in `.forge/project.cue` within project directories, specifies project-specific behavior

Every Catalyst Forge repository must contain a root `.forge` directory with a `repo.cue` file. Repositories without this structure are not recognized by the platform.

### CUE Modules

Every `.forge` directory constitutes a CUE module, initialized automatically by the CLI during project creation. Module names are auto-generated by the platform, abstracting this complexity from developers. Platform-provided CUE modules for schemas and validation are automatically added as dependencies.

### Configuration Files

All configuration files use CUE with concrete values (not definitions). Files within a `.forge` directory must declare the appropriate package:

- Repository configuration: `package repo`
- Project configuration: `package project`

Subdirectories within `.forge` are permitted but currently reserved for future use and ignored by the platform.

## Architecture

### Repository Structure & Conventions

#### File Organization

```
repository/
├── .forge/                    # Repository configuration (required)
│   ├── repo.cue              # Repository settings
│   └── cue.mod/              # CUE module definition
├── services/
│   ├── auth/
│   │   └── .forge/           # Project configuration
│   │       ├── project.cue   # Project settings
│   │       └── cue.mod/      # CUE module definition
│   └── api/
│       └── .forge/
│           ├── project.cue
│           └── cue.mod/
└── libraries/
    └── common/
        └── .forge/
            ├── project.cue
            └── cue.mod/
```

### CUE Configuration System

#### Schema Versioning & Evolution

Configuration schemas use semantic versioning specified in the `forgeVersion` field of `repo.cue`. This version applies to both repository and project schemas within that repository.

```cue
package repo

forgeVersion: "v1.0.0"
```

Version compatibility rules:
- **Major version changes**: Breaking changes requiring CLI upgrade
- **Minor version changes**: Additive changes, backward compatible
- **Patch version changes**: Validation fixes and documentation updates

The CLI validates major version compatibility and warns when encountering newer minor versions while continuing operation.

#### Repository Configuration Schema

The repository configuration (`repo.cue`) defines platform-wide settings that projects inherit or reference.

**Required Fields**
```cue
package repo

forgeVersion: "v1.0.0"  // Schema version (required)
```

**Tagging Strategy**
```cue
tagging: {
    strategy: "monorepo" | "tag-all"  // Required
}
```

- **monorepo**: Tags follow pattern `<project-name>/v*` for individual project releases
- **tag-all**: Bare version tags (`v*`) trigger releases for all projects

**Phase Definitions**

Repository defines available CI phases with group-based execution ordering:

```cue
phases: {
    check: {
        group: 1                              // Execution group (lower runs first)
        description: "Linting and formatting"
        timeout?: "10m"                       // Maximum execution time
        required?: false                      // Projects must participate
    }
    build: {
        group: 1                              // Runs parallel with check
        description: "Compile and package"
        timeout?: "20m"
    }
    test: {
        group: 2                              // Runs after group 1
        description: "Unit and integration tests"
        required: true                        // All projects must define test steps
        timeout?: "15m"
    }
}
```

**Publisher Configuration**

Repository defines available artifact publishers. Publisher credentials follow the platform's secret reference pattern using the ports and adapters approach (see [Core Architecture: Secret Management Patterns](01-core-architecture.md#secret-management-patterns)):

```cue
publishers: {
    [string]: {
        type: string  // Publisher type (docker, docs, github, crate, pypi, cue)

        // Type-specific fields vary by publisher type
        // See Build & Distribution specification for complete publisher schemas

        // Credentials use provider-specific schemas
        // The 'provider' field selects the secret provider implementation
        credentials: {
            provider: string  // Secret provider (aws, vault, github-oidc, kubernetes)
            // ... additional fields determined by provider schema
        }
    }
}
```

For complete publisher configuration schemas and examples, see [Build & Distribution: Repository Configuration](04-build-distribution.md#repository-configuration).

#### Project Configuration Schema

Project configuration (`project.cue`) defines individual project behavior and participation in platform workflows.

**Required Fields**

```cue
package project

name: "my-service"  // Unique within repository
```

Project names must:
- Be unique within the repository
- Contain only alphanumeric characters and hyphens
- Follow kebab-case convention (preferred)

**CI Configuration**

Projects declare phase participation and execution steps:

```cue
ci?: {
    phases?: {
        test?: {
            unit: {                    // Named step
                action: "earthly"
                target: "+unit"
                priority?: 0           // Higher values run first
                args?: ["--ci"]
                secrets?: [
                    {
                        provider: "aws"
                        path: "test/secrets"
                    }
                ]
            }
            integration: {
                action: "earthly"
                target: "+integration"
                priority?: -10        // Runs after unit
            }
        }
        build?: {
            compile: {
                action: "earthly"
                target: "+build"
            }
        }
    }
}
```

Steps within a phase run in parallel by default. Use the `priority` field to enforce ordering when necessary.

**Deployment Configuration**

Projects specify Kubernetes resources for deployment, primarily using platform-provided XRDs from the infrastructure abstractions catalog:

```cue
deployment?: {
    resources: [
        {
            apiVersion: "forge.io/v1"
            kind: "Deployment"
            metadata: {
                name: "myapp-web"
            }
            spec: {
                containers: [
                    {
                        name: "web"
                        image: @artifact("web.uri")
                        ports: [{containerPort: 8080}]
                    }
                ]
                replicas: 3
            }
        },
        {
            apiVersion: "forge.io/v1"
            kind: "Network"
            metadata: {
                name: "myapp-network"
            }
            spec: {
                workloadRef: "myapp-web"
                subdomain: "myapp"
                port: 8080
            }
        }
    ]
}
```

Resources can include:
- Platform XRDs from infrastructure abstractions catalog (recommended)
- Standard Kubernetes resources
- Mix of both in the same array

For the complete XRD catalog and specifications, see [Infrastructure Abstractions: XRD Catalog](08-infrastructure-abstractions.md#xrd-catalog).

**Release Configuration**

Projects define conditions for creating releases:

```cue
release?: {
    on?: [
        {branch: "main"},           // Regular expression for branch matching
        {branch: "release/.*"},     // Wildcard patterns supported
        {tag: true}                 // Tag interpretation per repository strategy
    ]
    enabled?: true                  // For opting out of tag-all strategy
}
```

Release triggers are evaluated during CI execution, not as event listeners.

**Artifact Configuration**

Projects specify build artifacts and their publication settings:

```cue
artifacts?: {
    [string]: {
        type: "container" | "binary" | "archive"  // Artifact type (required)
        producer: {
            // Single producer with type-specific configuration
            // Only one producer type allowed per artifact
            earthly?: {
                target: string
                args?: [...string]
                // Other Earthly-specific fields
            }
            // Future producers would follow same pattern
        }
        publishers: {
            // Multiple publishers, each with project-specific config
            [string]: {
                // Project-level publisher configuration
                // Fields depend on publisher type
            }
        }
    }
}
```

Artifacts are keyed by arbitrary names chosen by the project. Each artifact must declare its type explicitly and can have multiple publishers. Publishers are referenced by their names as defined in the repository configuration.

### Configuration Inheritance Patterns

Projects access repository configuration through custom CUE attributes rather than direct imports:

```cue
package project

ci: {
    phases: {
        test: {
            unit: {
                action: "earthly"
                target: "+test"
                timeout: @repo(path="phases.test.timeout")  // Inherit from repo
            }
        }
    }
}
```

This explicit inheritance model:
- Clarifies configuration sources
- Prevents naming conflicts
- Maintains clear separation between repository and project concerns

### Discovery Mechanisms & Rules

#### Discovery Rules

The platform discovers projects by traversing the repository filesystem:

1. Start from repository root
2. Traverse entire directory tree (no depth limit)
3. Identify directories containing `.forge/project.cue`
4. Respect `.gitignore` patterns
5. Ignore symbolic links
6. Skip nested `.forge` directories (forbidden configuration)

#### Discovery Process

Discovery executes as the first step in every CI pipeline:

1. Traverse filesystem following discovery rules
2. Load and validate each project configuration
3. Skip invalid projects with error logging
4. Build discovery output with valid projects
5. Construct phase execution groups

#### Discovery Output

The discovery process produces:

```json
{
    "repository": {
        "forgeVersion": "v1.0.0",
        "tagging": { "strategy": "monorepo" },
        "phases": { /* phase definitions */ },
        "publishers": { /* publisher configs */ }
    },
    "projects": [
        {
            "name": "auth-service",
            "path": "services/auth",
            "phases": {
                "test": [ /* step definitions */ ],
                "build": [ /* step definitions */ ]
            }
        }
    ],
    "phaseGroups": [
        { "group": 1, "phases": ["check", "build"] },
        { "group": 2, "phases": ["test"] }
    ]
}
```

### KRD Generation Process

#### Generation Process

Kubernetes Resource Definitions are generated from CUE during the release phase:

1. CUE configurations evaluated with custom attributes resolved
2. Deployment resources extracted and converted to JSON/YAML
3. Resources packaged into Release OCI image
4. Argo CD extracts resources during deployment

#### Validation

The platform performs validation at multiple stages:

- **Discovery phase**: CUE syntax and basic structure validation
- **Release phase**: Resource structure validation (apiVersion, kind, metadata)
- **Deployment phase**: Kubernetes API validation via admission controllers

The CLI provides local validation commands:
- `forge validate`: Check configuration validity
- `forge render`: Preview generated KRDs

#### Environment Separation

Projects have zero awareness of deployment environments:

- No environment-specific values in project configuration
- Two-tier EnvironmentConfig system provides cluster-wide and per-project overrides
- Releases are environment-agnostic snapshots
- XRDs designed to accept only environment-independent inputs

For complete environment configuration specifications, see [Infrastructure Abstractions: Environment Configuration Model](08-infrastructure-abstractions.md#environment-configuration-model).

## Configuration

### Secret Management

#### Port Contract: Secrets Synchronization

The platform defines a contract for external secret synchronization: references to external secret storage systems are materialized as Kubernetes Secret resources. This contract allows different secret backends to be used without changing application configuration.

**Contract Requirements:**

An adapter for this port must provide:
- Mechanism to reference secrets stored in external systems using a path or identifier scheme
- Synchronization of external secret values into Kubernetes Secret resources
- Authentication to the secret backend using cluster-native mechanisms
- Support for secret refresh to handle rotation and updates
- Hierarchical organization supporting environment-specific and global secret scopes

**Adapter Implementations:**

**AWS Secrets Manager (Production):** Currently implemented using External Secrets Operator. Provides IRSA-based authentication, automatic rotation support, and CloudWatch audit logging integration.

**External Secret Stores (On Premises):** Architecture supports integration with vault solutions or secret management systems that provide versioning, dynamic secret generation, and path-based organization through External Secrets Operator.

For complete secret management patterns and schemas, see [Core Architecture: Secret Management Patterns](01-core-architecture.md#secret-management-patterns).

Secret references are used consistently across CI step configurations, publisher credentials, and other secret access points. Secret values are never stored in configuration files. The platform resolves references at runtime using the provider-specific schemas defined in Core Architecture.

## Operations

### CLI Integration

The CLI provides project management capabilities:

**Commands**

- `forge init <project-name>`: Initialize new project with CUE module
- `forge validate`: Validate configuration against schema
- `forge render`: Preview KRD generation
- `forge discover`: List discovered projects (debugging)

**Error Handling**

The CLI provides:
- Clear, actionable error messages
- Configuration path in error output
- Debug mode for verbose diagnostics
- Suggestions for common issues

## Integration Points

For OCI formats and GitOps structure, see [Core Architecture: OCI Image Formats](01-core-architecture.md#oci-image-formats) and [Core Architecture: GitOps Repository Structure](01-core-architecture.md#gitops-repository-structure).

For infrastructure abstractions and XRD specifications, see [Infrastructure Abstractions](08-infrastructure-abstractions.md).

For pipeline discovery integration, see [Execution & Orchestration: Discovery](03-execution-orchestration.md#discovery).

For release resource rendering, see [Release & Deployment: Resource Rendering](05-release-deployment.md#resource-rendering).

## Reference

### Complete Configuration Examples

#### Minimal Project Configuration

```cue
package project

name: "hello-world"
```

#### Complete Project Configuration

```cue
package project

name: "auth-service"

ci: {
    phases: {
        test: {
            unit: {
                action: "earthly"
                target: "+unit-test"
            }
            lint: {
                action: "earthly"
                target: "+lint"
            }
        }
        build: {
            compile: {
                action: "earthly"
                target: "+build"
                priority: 10
            }
            package: {
                action: "earthly"
                target: "+package"
                priority: 5
            }
        }
    }
}

deployment: {
    resources: [
        {
            apiVersion: "webapp.platform.io/v1alpha1"
            kind: "WebApplication"
            metadata: {
                name: "auth-service"
            }
            spec: {
                compositionRevision: "v1.2.0"
                image: @artifact("api-server.publishers.ecr.uri")
                replicas: 3
                port: 8080
            }
        }
    ]
}

release: {
    on: [
        {branch: "main"},
        {tag: true}
    ]
}

artifacts: {
    "api-server": {
        type: "container"
        producer: {
            earthly: {
                target: "+build"
                args: ["--platform=linux/amd64"]
            }
        }
        publishers: {
            "docker": {
                tags: ["latest", "v1.0.0"]
            }
            "ecr": {
                tags: ["v1.0.0"]
            }
        }
    }
    "cli-tool": {
        type: "binary"
        producer: {
            earthly: {
                target: "+build-cli"
            }
        }
        publishers: {
            "github-releases": {
                asset_name: "auth-cli-linux-amd64"
            }
        }
    }
}
```

#### Repository Configuration Example

```cue
package repo

forgeVersion: "v1.0.0"

tagging: {
    strategy: "monorepo"
}

phases: {
    lint: {
        group: 1
        description: "Code quality checks"
        timeout: "5m"
        required: true
    }
    build: {
        group: 1
        description: "Build artifacts"
        timeout: "15m"
    }
    test: {
        group: 2
        description: "Run test suites"
        timeout: "20m"
        required: true
    }
    publish: {
        group: 3
        description: "Publish artifacts"
        timeout: "10m"
    }
}

publishers: {
    docker: {
        type: "docker"
        registry: "registry.company.com"
        namespace: "platform-team"
        credentials: {
            provider: "aws"
            path: "docker/registry/creds"
        }
    }
    ecr: {
        type: "docker"
        registry: "123456789.dkr.ecr.us-east-1.amazonaws.com"
        namespace: "platform"
        credentials: {
            provider: "aws"
            path: "ecr/credentials"
        }
    }
    github-releases: {
        type: "github"
        owner: "company"
        repo: "tools"
        credentials: {
            provider: "vault"
            path: "github/token"
        }
    }
}
```

## Examples

For additional configuration examples, see [Configuration & Discovery: Complete Configuration Examples](#complete-configuration-examples).

## Constraints & Limitations

### Structural Constraints

- `.forge` directories cannot be nested
- Repository must have root `.forge/repo.cue`
- Project names must be unique within repository
- All configuration must be valid CUE

### Phase Constraints

- Projects can only participate in repository-defined phases
- Required phases cannot be skipped
- Steps within phases run in parallel unless prioritized

### Resource Constraints

- Initial implementation supports only Earthly actions
- KRD validation limited to basic structure
- No Kubernetes-specific deprecation checking

## Future Enhancements

### Type-Safe Resource Definitions

Future versions will support importing CUE schemas generated from XRDs:

```cue
import webapp "forge.company.com/xrds/webapp/v1alpha1"

deployment: {
    resources: [
        webapp.#WebApplication & {
            metadata: name: "my-app"
            spec: {
                image: @artifact(name="docker")
                replicas: 3
            }
        }
    ]
}
```

### Additional Action Types

The step action schema will expand beyond Earthly:

```cue
#Step: #EarthlyStep | #ScriptStep | #ContainerStep

#ScriptStep: {
    action: "script"
    run: string
    shell?: string
}
```

---

**Component Owner**: Configuration System
**Shared Concepts**: See [Core Architecture](01-core-architecture.md)
**Last Updated**: 2025-10-02
